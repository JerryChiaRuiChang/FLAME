---
title: "Apply the FLAME Algorithm to Synthetic Data"
author: "Jerry Chia-Rui Chang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Apply the FLAME Algorithm to Synthetic Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, cache=TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(500)
library(FLAME)
```

This vignette demonstrates how to implement the `FLAME` package. We applied `FLAME_bit`, `FLAME_PostgreSQL`, and `FLAME_SQLite` to synthetic data.  

## Generate synthetic data

`Data_Generation` function creates simulated data with specific characteristics and known treatment effects. The following function is used to generate synthetic data.  

\newline

$$
\begin{aligned}
& y_{i} = \sum_{j = 1}^{n}\alpha_{j}x_{j} + T_{i}\sum_{j = 1}^{n}\beta_{j}x_{j} + T_{i} \cdot U \sum_{j=1..5, \gamma = 1...5, \gamma > j} x_{j}x_{\gamma}
\end{aligned}
$$
$T_{i} \in \{0,1\}$ indicates whether a unit $i$ is treated or control, and $U$ represents the coefficient of non-linear term. Here, $x_{j} \sim$ Bernoulli(0.5), $\alpha_{j} \sim N(10s, 1)$ with $s \sim Uniform\{-1,1\}$, and $\beta_{j} \sim N(1.5,0.15)$. For package demonstration, the simulated data contains 5,000 treated units and 5,000 control units with $U = 5$. In addition, there are 10 important covariates and 5 unimportant covariates. Important covariates are those used to generate the true outcome $y_{i}$, whereas unimportant covariates are random samples from Bernoulli(0.5). For the simulated data below, $x_{1}, x_{2}, ..., x_{10}$ are important covariates and $x_{11}, x_{12}, ..., x_{15}$ are unimportant covariates. We assume holdout training set to be the same as simulated data. The following code is used to generate simulated data.

```{r}
set.seed(1234) # set seed for reproducibility
sim_data = FLAME::Data_Generation(num_control = 5000, num_treated = 5000, 
                               num_cov_dense = 10, num_cov_unimportant = 5, U = 5)

sim_holdout = sim_data

head(sim_data)
```

## Bit vectors implementation

We run `FLAME_bit` function with the following command. The required inputs include (1) input data and (2) holdout training set. Note that if we would like to compute the variance of each matched group, please specify optioanl argument `compute_var = TRUE`. Since the variance of each matched group is the sum of the variance of the treated units and the variance of the control units, each matched group should contain at least 2 treated units and 2 control units. Therefore, it is expected that less matched units will be found in earlier iteration if `compute_var` is specified to be TRUE.

```{r}
result_bit <- FLAME_bit(data = sim_data, holdout = sim_holdout)
```

The outputs contain four elements, including 
1. covaraite_list: list of covariates FLAME performs matching at each iteration
2. matched_group: list of dataframe showing matched groups' sizes, conditional average treatment effects (CATEs), and variance (if `compute_var = TRUE`) at each iteration
3. match_quality: matching quality at each iteration
4. matched_data: the original data with additional column *matched*, indicating the number of covariates each unit is matched. If a unit is never matched, then *matched* will be 0.

## Database systems implementation 

For database systems implementation, `FLAME` package provides two versions - SQLite and PostgreSQL. PostgreSQL version requires installation of external database system and has faster implementation. SQLite version does not require external database system but its implementation is slower than the PostgreSQL version. 

### PostgreSQL

If your computer does not have PostgreSQL installed, install from [here](https://www.postgresql.org/download/). For connecting and setup of PostgreSQL server, please refer to [tutorial](http://www.postgresqltutorial.com/connect-to-postgresql-database/).  

\newline

Connect to PostgreSQL in R and run `FLAME_PostgreSQL` function with the following command. Note that it is required to name the connection as **db** and disconnect it once done. The required inputs include (1) database connection (**db**), (2) input data, and (3) holdout training set. The outputs of `FLAME_PostgreSQL` are the same as the outputs of `FLAME_bit`.

```{r}
# Connect to PostgreSQL
drv <- dbDriver('PostgreSQL')

# Name the connection as db
db <- dbConnect(drv, user="postgres", dbname="FLAME", host='localhost',
             port=5432, password = 'new_password')

# Run FLAME_PostgreSQL 
result_PostgreSQL <- FLAME::FLAME_PostgreSQL(db = db, data = sim_data, holdout = sim_holdout)

# Disconnect from db
dbDisconnect(db)
```

### SQLite

Connect to a temporary database in R and run `FLAME_SQLite` function with the following command. Note that it is required to name the connection as **db**. The required inputs include (1) database connection (**db**), (2) input data, and (3) holdout training set. In this case, we also specify `compute_var = TRUE`. The outputs of `FLAME_SQLite` are the same as the outputs of `FLAME_bit` and `FLAME_PostgreSQL`.
```{r}
#Name the connection as db
db <- dbConnect(SQLite(),"tempdb") 

#Run FLAME_SQLite
result_SQLite <- FLAME::FLAME_SQLite(db = db, data = sim_data, holdout = sim_holdout)

#Disconnect from db
dbDisconnect(db)
```

## Summary & Compare Outputs

We compare the results of bit vectors, PostgreSQL, and SQLite implementations, where all three should yield the same outputs. 

(1) Apply summary function to examine the number of matched units and average treatment effect.

```{r}
summary(result_bit)
summary(result_SQLite)
summary(result_PostgreSQL)
```

(2) The covariates FLAME performs matching at the $8^{th}$ iteration.
```{r}
result_bit$covariate_list[[8]] # bit vectors
result_PostgreSQL$covariate_list[[8]] #PostgreSQL
result_SQLite$covariate_list[[8]] #SQLite
```

(3) Each matched group's size, conditional average treatment effect (CATE), and variance at the $10^{th}$ iteration. Note that if we specify `compute_var = FLASE` when running FLAME, the variance column will not be in the output.
```{r}
head(result_bit$matched_group[[10]]) # bit vectors
head(result_PostgreSQL$matched_group[[10]]) #PostgreSQL
head(result_SQLite$matched_group[[10]]) #SQLite
```

(4) Matching Quality at each iteration
```{r}
result_bit$match_quality # bit vectors
result_PostgreSQL$match_quality #PostgreSQL
result_SQLite$match_quality #SQLite
```
